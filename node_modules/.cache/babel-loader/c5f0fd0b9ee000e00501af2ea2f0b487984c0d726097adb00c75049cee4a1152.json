{"ast":null,"code":"/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction Keycloak(config) {\n  if (!(this instanceof Keycloak)) {\n    throw new Error(\"The 'Keycloak' constructor must be invoked with 'new'.\");\n  }\n  if (typeof config !== 'string' && !isObject(config)) {\n    throw new Error(\"The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.\");\n  }\n  if (isObject(config)) {\n    const requiredProperties = 'oidcProvider' in config ? ['clientId'] : ['url', 'realm', 'clientId'];\n    for (const property of requiredProperties) {\n      if (!config[property]) {\n        throw new Error(`The configuration object is missing the required '${property}' property.`);\n      }\n    }\n  }\n  var kc = this;\n  var adapter;\n  var refreshQueue = [];\n  var callbackStorage;\n  var loginIframe = {\n    enable: true,\n    callbackList: [],\n    interval: 5\n  };\n  kc.didInitialize = false;\n  var useNonce = true;\n  var logInfo = createLogger(console.info);\n  var logWarn = createLogger(console.warn);\n  if (!globalThis.isSecureContext) {\n    logWarn(\"[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\\n\" + \"Continuing to run your application insecurely will lead to unexpected behavior and breakage.\\n\\n\" + \"For more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\");\n  }\n  kc.init = function (initOptions = {}) {\n    if (kc.didInitialize) {\n      throw new Error(\"A 'Keycloak' instance can only be initialized once.\");\n    }\n    kc.didInitialize = true;\n    kc.authenticated = false;\n    callbackStorage = createCallbackStorage();\n    var adapters = ['default', 'cordova', 'cordova-native'];\n    if (adapters.indexOf(initOptions.adapter) > -1) {\n      adapter = loadAdapter(initOptions.adapter);\n    } else if (typeof initOptions.adapter === \"object\") {\n      adapter = initOptions.adapter;\n    } else {\n      if (window.Cordova || window.cordova) {\n        adapter = loadAdapter('cordova');\n      } else {\n        adapter = loadAdapter();\n      }\n    }\n    if (typeof initOptions.useNonce !== 'undefined') {\n      useNonce = initOptions.useNonce;\n    }\n    if (typeof initOptions.checkLoginIframe !== 'undefined') {\n      loginIframe.enable = initOptions.checkLoginIframe;\n    }\n    if (initOptions.checkLoginIframeInterval) {\n      loginIframe.interval = initOptions.checkLoginIframeInterval;\n    }\n    if (initOptions.onLoad === 'login-required') {\n      kc.loginRequired = true;\n    }\n    if (initOptions.responseMode) {\n      if (initOptions.responseMode === 'query' || initOptions.responseMode === 'fragment') {\n        kc.responseMode = initOptions.responseMode;\n      } else {\n        throw 'Invalid value for responseMode';\n      }\n    }\n    if (initOptions.flow) {\n      switch (initOptions.flow) {\n        case 'standard':\n          kc.responseType = 'code';\n          break;\n        case 'implicit':\n          kc.responseType = 'id_token token';\n          break;\n        case 'hybrid':\n          kc.responseType = 'code id_token token';\n          break;\n        default:\n          throw 'Invalid value for flow';\n      }\n      kc.flow = initOptions.flow;\n    }\n    if (initOptions.timeSkew != null) {\n      kc.timeSkew = initOptions.timeSkew;\n    }\n    if (initOptions.redirectUri) {\n      kc.redirectUri = initOptions.redirectUri;\n    }\n    if (initOptions.silentCheckSsoRedirectUri) {\n      kc.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;\n    }\n    if (typeof initOptions.silentCheckSsoFallback === 'boolean') {\n      kc.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;\n    } else {\n      kc.silentCheckSsoFallback = true;\n    }\n    if (typeof initOptions.pkceMethod !== \"undefined\") {\n      if (initOptions.pkceMethod !== \"S256\" && initOptions.pkceMethod !== false) {\n        throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`);\n      }\n      kc.pkceMethod = initOptions.pkceMethod;\n    } else {\n      kc.pkceMethod = \"S256\";\n    }\n    if (typeof initOptions.enableLogging === 'boolean') {\n      kc.enableLogging = initOptions.enableLogging;\n    } else {\n      kc.enableLogging = false;\n    }\n    if (initOptions.logoutMethod === 'POST') {\n      kc.logoutMethod = 'POST';\n    } else {\n      kc.logoutMethod = 'GET';\n    }\n    if (typeof initOptions.scope === 'string') {\n      kc.scope = initOptions.scope;\n    }\n    if (typeof initOptions.acrValues === 'string') {\n      kc.acrValues = initOptions.acrValues;\n    }\n    if (typeof initOptions.messageReceiveTimeout === 'number' && initOptions.messageReceiveTimeout > 0) {\n      kc.messageReceiveTimeout = initOptions.messageReceiveTimeout;\n    } else {\n      kc.messageReceiveTimeout = 10000;\n    }\n    if (!kc.responseMode) {\n      kc.responseMode = 'fragment';\n    }\n    if (!kc.responseType) {\n      kc.responseType = 'code';\n      kc.flow = 'standard';\n    }\n    var promise = createPromise();\n    var initPromise = createPromise();\n    initPromise.promise.then(function () {\n      kc.onReady && kc.onReady(kc.authenticated);\n      promise.setSuccess(kc.authenticated);\n    }).catch(function (error) {\n      promise.setError(error);\n    });\n    var configPromise = loadConfig();\n    function onLoad() {\n      var doLogin = function (prompt) {\n        if (!prompt) {\n          options.prompt = 'none';\n        }\n        if (initOptions.locale) {\n          options.locale = initOptions.locale;\n        }\n        kc.login(options).then(function () {\n          initPromise.setSuccess();\n        }).catch(function (error) {\n          initPromise.setError(error);\n        });\n      };\n      var checkSsoSilently = async function () {\n        var ifrm = document.createElement(\"iframe\");\n        var src = await kc.createLoginUrl({\n          prompt: 'none',\n          redirectUri: kc.silentCheckSsoRedirectUri\n        });\n        ifrm.setAttribute(\"src\", src);\n        ifrm.setAttribute(\"sandbox\", \"allow-storage-access-by-user-activation allow-scripts allow-same-origin\");\n        ifrm.setAttribute(\"title\", \"keycloak-silent-check-sso\");\n        ifrm.style.display = \"none\";\n        document.body.appendChild(ifrm);\n        var messageCallback = function (event) {\n          if (event.origin !== window.location.origin || ifrm.contentWindow !== event.source) {\n            return;\n          }\n          var oauth = parseCallback(event.data);\n          processCallback(oauth, initPromise);\n          document.body.removeChild(ifrm);\n          window.removeEventListener(\"message\", messageCallback);\n        };\n        window.addEventListener(\"message\", messageCallback);\n      };\n      var options = {};\n      switch (initOptions.onLoad) {\n        case 'check-sso':\n          if (loginIframe.enable) {\n            setupCheckLoginIframe().then(function () {\n              checkLoginIframe().then(function (unchanged) {\n                if (!unchanged) {\n                  kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n                } else {\n                  initPromise.setSuccess();\n                }\n              }).catch(function (error) {\n                initPromise.setError(error);\n              });\n            });\n          } else {\n            kc.silentCheckSsoRedirectUri ? checkSsoSilently() : doLogin(false);\n          }\n          break;\n        case 'login-required':\n          doLogin(true);\n          break;\n        default:\n          throw 'Invalid value for onLoad';\n      }\n    }\n    function processInit() {\n      var callback = parseCallback(window.location.href);\n      if (callback) {\n        window.history.replaceState(window.history.state, null, callback.newUrl);\n      }\n      if (callback && callback.valid) {\n        return setupCheckLoginIframe().then(function () {\n          processCallback(callback, initPromise);\n        }).catch(function (error) {\n          initPromise.setError(error);\n        });\n      }\n      if (initOptions.token && initOptions.refreshToken) {\n        setToken(initOptions.token, initOptions.refreshToken, initOptions.idToken);\n        if (loginIframe.enable) {\n          setupCheckLoginIframe().then(function () {\n            checkLoginIframe().then(function (unchanged) {\n              if (unchanged) {\n                kc.onAuthSuccess && kc.onAuthSuccess();\n                initPromise.setSuccess();\n                scheduleCheckIframe();\n              } else {\n                initPromise.setSuccess();\n              }\n            }).catch(function (error) {\n              initPromise.setError(error);\n            });\n          });\n        } else {\n          kc.updateToken(-1).then(function () {\n            kc.onAuthSuccess && kc.onAuthSuccess();\n            initPromise.setSuccess();\n          }).catch(function (error) {\n            kc.onAuthError && kc.onAuthError();\n            if (initOptions.onLoad) {\n              onLoad();\n            } else {\n              initPromise.setError(error);\n            }\n          });\n        }\n      } else if (initOptions.onLoad) {\n        onLoad();\n      } else {\n        initPromise.setSuccess();\n      }\n    }\n    configPromise.then(function () {\n      check3pCookiesSupported().then(processInit).catch(function (error) {\n        promise.setError(error);\n      });\n    });\n    configPromise.catch(function (error) {\n      promise.setError(error);\n    });\n    return promise.promise;\n  };\n  kc.login = function (options) {\n    return adapter.login(options);\n  };\n  function generateRandomData(len) {\n    if (typeof crypto === \"undefined\" || typeof crypto.getRandomValues === \"undefined\") {\n      throw new Error(\"Web Crypto API is not available.\");\n    }\n    return crypto.getRandomValues(new Uint8Array(len));\n  }\n  function generateCodeVerifier(len) {\n    return generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');\n  }\n  function generateRandomString(len, alphabet) {\n    var randomData = generateRandomData(len);\n    var chars = new Array(len);\n    for (var i = 0; i < len; i++) {\n      chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);\n    }\n    return String.fromCharCode.apply(null, chars);\n  }\n  async function generatePkceChallenge(pkceMethod, codeVerifier) {\n    if (pkceMethod !== \"S256\") {\n      throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`);\n    }\n\n    // hash codeVerifier, then encode as url-safe base64 without padding\n    const hashBytes = new Uint8Array(await sha256Digest(codeVerifier));\n    const encodedHash = bytesToBase64(hashBytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n    return encodedHash;\n  }\n  function buildClaimsParameter(requestedAcr) {\n    var claims = {\n      id_token: {\n        acr: requestedAcr\n      }\n    };\n    return JSON.stringify(claims);\n  }\n  kc.createLoginUrl = async function (options) {\n    var state = createUUID();\n    var nonce = createUUID();\n    var redirectUri = adapter.redirectUri(options);\n    var callbackState = {\n      state: state,\n      nonce: nonce,\n      redirectUri: encodeURIComponent(redirectUri),\n      loginOptions: options\n    };\n    if (options && options.prompt) {\n      callbackState.prompt = options.prompt;\n    }\n    var baseUrl;\n    if (options && options.action == 'register') {\n      baseUrl = kc.endpoints.register();\n    } else {\n      baseUrl = kc.endpoints.authorize();\n    }\n    var scope = options && options.scope || kc.scope;\n    if (!scope) {\n      // if scope is not set, default to \"openid\"\n      scope = \"openid\";\n    } else if (scope.indexOf(\"openid\") === -1) {\n      // if openid scope is missing, prefix the given scopes with it\n      scope = \"openid \" + scope;\n    }\n    var url = baseUrl + '?client_id=' + encodeURIComponent(kc.clientId) + '&redirect_uri=' + encodeURIComponent(redirectUri) + '&state=' + encodeURIComponent(state) + '&response_mode=' + encodeURIComponent(kc.responseMode) + '&response_type=' + encodeURIComponent(kc.responseType) + '&scope=' + encodeURIComponent(scope);\n    if (useNonce) {\n      url = url + '&nonce=' + encodeURIComponent(nonce);\n    }\n    if (options && options.prompt) {\n      url += '&prompt=' + encodeURIComponent(options.prompt);\n    }\n    if (options && typeof options.maxAge === 'number') {\n      url += '&max_age=' + encodeURIComponent(options.maxAge);\n    }\n    if (options && options.loginHint) {\n      url += '&login_hint=' + encodeURIComponent(options.loginHint);\n    }\n    if (options && options.idpHint) {\n      url += '&kc_idp_hint=' + encodeURIComponent(options.idpHint);\n    }\n    if (options && options.action && options.action != 'register') {\n      url += '&kc_action=' + encodeURIComponent(options.action);\n    }\n    if (options && options.locale) {\n      url += '&ui_locales=' + encodeURIComponent(options.locale);\n    }\n    if (options && options.acr) {\n      var claimsParameter = buildClaimsParameter(options.acr);\n      url += '&claims=' + encodeURIComponent(claimsParameter);\n    }\n    if (options && options.acrValues || kc.acrValues) {\n      url += '&acr_values=' + encodeURIComponent(options.acrValues || kc.acrValues);\n    }\n    if (kc.pkceMethod) {\n      try {\n        const codeVerifier = generateCodeVerifier(96);\n        const pkceChallenge = await generatePkceChallenge(kc.pkceMethod, codeVerifier);\n        callbackState.pkceCodeVerifier = codeVerifier;\n        url += '&code_challenge=' + pkceChallenge;\n        url += '&code_challenge_method=' + kc.pkceMethod;\n      } catch (error) {\n        throw new Error(\"Failed to generate PKCE challenge.\", {\n          cause: error\n        });\n      }\n    }\n    callbackStorage.add(callbackState);\n    return url;\n  };\n  kc.logout = function (options) {\n    return adapter.logout(options);\n  };\n  kc.createLogoutUrl = function (options) {\n    const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n    if (logoutMethod === 'POST') {\n      return kc.endpoints.logout();\n    }\n    var url = kc.endpoints.logout() + '?client_id=' + encodeURIComponent(kc.clientId) + '&post_logout_redirect_uri=' + encodeURIComponent(adapter.redirectUri(options, false));\n    if (kc.idToken) {\n      url += '&id_token_hint=' + encodeURIComponent(kc.idToken);\n    }\n    return url;\n  };\n  kc.register = function (options) {\n    return adapter.register(options);\n  };\n  kc.createRegisterUrl = async function (options) {\n    if (!options) {\n      options = {};\n    }\n    options.action = 'register';\n    return await kc.createLoginUrl(options);\n  };\n  kc.createAccountUrl = function (options) {\n    var realm = getRealmUrl();\n    var url = undefined;\n    if (typeof realm !== 'undefined') {\n      url = realm + '/account' + '?referrer=' + encodeURIComponent(kc.clientId) + '&referrer_uri=' + encodeURIComponent(adapter.redirectUri(options));\n    }\n    return url;\n  };\n  kc.accountManagement = function () {\n    return adapter.accountManagement();\n  };\n  kc.hasRealmRole = function (role) {\n    var access = kc.realmAccess;\n    return !!access && access.roles.indexOf(role) >= 0;\n  };\n  kc.hasResourceRole = function (role, resource) {\n    if (!kc.resourceAccess) {\n      return false;\n    }\n    var access = kc.resourceAccess[resource || kc.clientId];\n    return !!access && access.roles.indexOf(role) >= 0;\n  };\n  kc.loadUserProfile = function () {\n    var url = getRealmUrl() + '/account';\n    var req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n    req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n    var promise = createPromise();\n    req.onreadystatechange = function () {\n      if (req.readyState == 4) {\n        if (req.status == 200) {\n          kc.profile = JSON.parse(req.responseText);\n          promise.setSuccess(kc.profile);\n        } else {\n          promise.setError();\n        }\n      }\n    };\n    req.send();\n    return promise.promise;\n  };\n  kc.loadUserInfo = function () {\n    var url = kc.endpoints.userinfo();\n    var req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n    req.setRequestHeader('Authorization', 'bearer ' + kc.token);\n    var promise = createPromise();\n    req.onreadystatechange = function () {\n      if (req.readyState == 4) {\n        if (req.status == 200) {\n          kc.userInfo = JSON.parse(req.responseText);\n          promise.setSuccess(kc.userInfo);\n        } else {\n          promise.setError();\n        }\n      }\n    };\n    req.send();\n    return promise.promise;\n  };\n  kc.isTokenExpired = function (minValidity) {\n    if (!kc.tokenParsed || !kc.refreshToken && kc.flow != 'implicit') {\n      throw 'Not authenticated';\n    }\n    if (kc.timeSkew == null) {\n      logInfo('[KEYCLOAK] Unable to determine if token is expired as timeskew is not set');\n      return true;\n    }\n    var expiresIn = kc.tokenParsed['exp'] - Math.ceil(new Date().getTime() / 1000) + kc.timeSkew;\n    if (minValidity) {\n      if (isNaN(minValidity)) {\n        throw 'Invalid minValidity';\n      }\n      expiresIn -= minValidity;\n    }\n    return expiresIn < 0;\n  };\n  kc.updateToken = function (minValidity) {\n    var promise = createPromise();\n    if (!kc.refreshToken) {\n      promise.setError();\n      return promise.promise;\n    }\n    minValidity = minValidity || 5;\n    var exec = function () {\n      var refreshToken = false;\n      if (minValidity == -1) {\n        refreshToken = true;\n        logInfo('[KEYCLOAK] Refreshing token: forced refresh');\n      } else if (!kc.tokenParsed || kc.isTokenExpired(minValidity)) {\n        refreshToken = true;\n        logInfo('[KEYCLOAK] Refreshing token: token expired');\n      }\n      if (!refreshToken) {\n        promise.setSuccess(false);\n      } else {\n        var params = 'grant_type=refresh_token&' + 'refresh_token=' + kc.refreshToken;\n        var url = kc.endpoints.token();\n        refreshQueue.push(promise);\n        if (refreshQueue.length == 1) {\n          var req = new XMLHttpRequest();\n          req.open('POST', url, true);\n          req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n          req.withCredentials = true;\n          params += '&client_id=' + encodeURIComponent(kc.clientId);\n          var timeLocal = new Date().getTime();\n          req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n              if (req.status == 200) {\n                logInfo('[KEYCLOAK] Token refreshed');\n                timeLocal = (timeLocal + new Date().getTime()) / 2;\n                var tokenResponse = JSON.parse(req.responseText);\n                setToken(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], timeLocal);\n                kc.onAuthRefreshSuccess && kc.onAuthRefreshSuccess();\n                for (var p = refreshQueue.pop(); p != null; p = refreshQueue.pop()) {\n                  p.setSuccess(true);\n                }\n              } else {\n                logWarn('[KEYCLOAK] Failed to refresh token');\n                if (req.status == 400) {\n                  kc.clearToken();\n                }\n                kc.onAuthRefreshError && kc.onAuthRefreshError();\n                for (var p = refreshQueue.pop(); p != null; p = refreshQueue.pop()) {\n                  p.setError(\"Failed to refresh token: An unexpected HTTP error occurred while attempting to refresh the token.\");\n                }\n              }\n            }\n          };\n          req.send(params);\n        }\n      }\n    };\n    if (loginIframe.enable) {\n      var iframePromise = checkLoginIframe();\n      iframePromise.then(function () {\n        exec();\n      }).catch(function (error) {\n        promise.setError(error);\n      });\n    } else {\n      exec();\n    }\n    return promise.promise;\n  };\n  kc.clearToken = function () {\n    if (kc.token) {\n      setToken(null, null, null);\n      kc.onAuthLogout && kc.onAuthLogout();\n      if (kc.loginRequired) {\n        kc.login();\n      }\n    }\n  };\n  function getRealmUrl() {\n    if (typeof kc.authServerUrl !== 'undefined') {\n      if (kc.authServerUrl.charAt(kc.authServerUrl.length - 1) == '/') {\n        return kc.authServerUrl + 'realms/' + encodeURIComponent(kc.realm);\n      } else {\n        return kc.authServerUrl + '/realms/' + encodeURIComponent(kc.realm);\n      }\n    } else {\n      return undefined;\n    }\n  }\n  function getOrigin() {\n    if (!window.location.origin) {\n      return window.location.protocol + \"//\" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n    } else {\n      return window.location.origin;\n    }\n  }\n  function processCallback(oauth, promise) {\n    var code = oauth.code;\n    var error = oauth.error;\n    var prompt = oauth.prompt;\n    var timeLocal = new Date().getTime();\n    if (oauth['kc_action_status']) {\n      kc.onActionUpdate && kc.onActionUpdate(oauth['kc_action_status'], oauth['kc_action']);\n    }\n    if (error) {\n      if (prompt != 'none') {\n        if (oauth.error_description && oauth.error_description === \"authentication_expired\") {\n          kc.login(oauth.loginOptions);\n        } else {\n          var errorData = {\n            error: error,\n            error_description: oauth.error_description\n          };\n          kc.onAuthError && kc.onAuthError(errorData);\n          promise && promise.setError(errorData);\n        }\n      } else {\n        promise && promise.setSuccess();\n      }\n      return;\n    } else if (kc.flow != 'standard' && (oauth.access_token || oauth.id_token)) {\n      authSuccess(oauth.access_token, null, oauth.id_token, true);\n    }\n    if (kc.flow != 'implicit' && code) {\n      var params = 'code=' + code + '&grant_type=authorization_code';\n      var url = kc.endpoints.token();\n      var req = new XMLHttpRequest();\n      req.open('POST', url, true);\n      req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n      params += '&client_id=' + encodeURIComponent(kc.clientId);\n      params += '&redirect_uri=' + oauth.redirectUri;\n      if (oauth.pkceCodeVerifier) {\n        params += '&code_verifier=' + oauth.pkceCodeVerifier;\n      }\n      req.withCredentials = true;\n      req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n          if (req.status == 200) {\n            var tokenResponse = JSON.parse(req.responseText);\n            authSuccess(tokenResponse['access_token'], tokenResponse['refresh_token'], tokenResponse['id_token'], kc.flow === 'standard');\n            scheduleCheckIframe();\n          } else {\n            kc.onAuthError && kc.onAuthError();\n            promise && promise.setError();\n          }\n        }\n      };\n      req.send(params);\n    }\n    function authSuccess(accessToken, refreshToken, idToken, fulfillPromise) {\n      timeLocal = (timeLocal + new Date().getTime()) / 2;\n      setToken(accessToken, refreshToken, idToken, timeLocal);\n      if (useNonce && kc.idTokenParsed && kc.idTokenParsed.nonce != oauth.storedNonce) {\n        logInfo('[KEYCLOAK] Invalid nonce, clearing token');\n        kc.clearToken();\n        promise && promise.setError();\n      } else {\n        if (fulfillPromise) {\n          kc.onAuthSuccess && kc.onAuthSuccess();\n          promise && promise.setSuccess();\n        }\n      }\n    }\n  }\n  function loadConfig() {\n    var promise = createPromise();\n    var configUrl;\n    if (typeof config === 'string') {\n      configUrl = config;\n    }\n    function setupOidcEndoints(oidcConfiguration) {\n      if (!oidcConfiguration) {\n        kc.endpoints = {\n          authorize: function () {\n            return getRealmUrl() + '/protocol/openid-connect/auth';\n          },\n          token: function () {\n            return getRealmUrl() + '/protocol/openid-connect/token';\n          },\n          logout: function () {\n            return getRealmUrl() + '/protocol/openid-connect/logout';\n          },\n          checkSessionIframe: function () {\n            return getRealmUrl() + '/protocol/openid-connect/login-status-iframe.html';\n          },\n          thirdPartyCookiesIframe: function () {\n            return getRealmUrl() + '/protocol/openid-connect/3p-cookies/step1.html';\n          },\n          register: function () {\n            return getRealmUrl() + '/protocol/openid-connect/registrations';\n          },\n          userinfo: function () {\n            return getRealmUrl() + '/protocol/openid-connect/userinfo';\n          }\n        };\n      } else {\n        kc.endpoints = {\n          authorize: function () {\n            return oidcConfiguration.authorization_endpoint;\n          },\n          token: function () {\n            return oidcConfiguration.token_endpoint;\n          },\n          logout: function () {\n            if (!oidcConfiguration.end_session_endpoint) {\n              throw \"Not supported by the OIDC server\";\n            }\n            return oidcConfiguration.end_session_endpoint;\n          },\n          checkSessionIframe: function () {\n            if (!oidcConfiguration.check_session_iframe) {\n              throw \"Not supported by the OIDC server\";\n            }\n            return oidcConfiguration.check_session_iframe;\n          },\n          register: function () {\n            throw 'Redirection to \"Register user\" page not supported in standard OIDC mode';\n          },\n          userinfo: function () {\n            if (!oidcConfiguration.userinfo_endpoint) {\n              throw \"Not supported by the OIDC server\";\n            }\n            return oidcConfiguration.userinfo_endpoint;\n          }\n        };\n      }\n    }\n    if (configUrl) {\n      var req = new XMLHttpRequest();\n      req.open('GET', configUrl, true);\n      req.setRequestHeader('Accept', 'application/json');\n      req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n          if (req.status == 200 || fileLoaded(req)) {\n            var config = JSON.parse(req.responseText);\n            kc.authServerUrl = config['auth-server-url'];\n            kc.realm = config['realm'];\n            kc.clientId = config['resource'];\n            setupOidcEndoints(null);\n            promise.setSuccess();\n          } else {\n            promise.setError();\n          }\n        }\n      };\n      req.send();\n    } else {\n      kc.clientId = config.clientId;\n      var oidcProvider = config['oidcProvider'];\n      if (!oidcProvider) {\n        kc.authServerUrl = config.url;\n        kc.realm = config.realm;\n        setupOidcEndoints(null);\n        promise.setSuccess();\n      } else {\n        if (typeof oidcProvider === 'string') {\n          var oidcProviderConfigUrl;\n          if (oidcProvider.charAt(oidcProvider.length - 1) == '/') {\n            oidcProviderConfigUrl = oidcProvider + '.well-known/openid-configuration';\n          } else {\n            oidcProviderConfigUrl = oidcProvider + '/.well-known/openid-configuration';\n          }\n          var req = new XMLHttpRequest();\n          req.open('GET', oidcProviderConfigUrl, true);\n          req.setRequestHeader('Accept', 'application/json');\n          req.onreadystatechange = function () {\n            if (req.readyState == 4) {\n              if (req.status == 200 || fileLoaded(req)) {\n                var oidcProviderConfig = JSON.parse(req.responseText);\n                setupOidcEndoints(oidcProviderConfig);\n                promise.setSuccess();\n              } else {\n                promise.setError();\n              }\n            }\n          };\n          req.send();\n        } else {\n          setupOidcEndoints(oidcProvider);\n          promise.setSuccess();\n        }\n      }\n    }\n    return promise.promise;\n  }\n  function fileLoaded(xhr) {\n    return xhr.status == 0 && xhr.responseText && xhr.responseURL.startsWith('file:');\n  }\n  function setToken(token, refreshToken, idToken, timeLocal) {\n    if (kc.tokenTimeoutHandle) {\n      clearTimeout(kc.tokenTimeoutHandle);\n      kc.tokenTimeoutHandle = null;\n    }\n    if (refreshToken) {\n      kc.refreshToken = refreshToken;\n      kc.refreshTokenParsed = decodeToken(refreshToken);\n    } else {\n      delete kc.refreshToken;\n      delete kc.refreshTokenParsed;\n    }\n    if (idToken) {\n      kc.idToken = idToken;\n      kc.idTokenParsed = decodeToken(idToken);\n    } else {\n      delete kc.idToken;\n      delete kc.idTokenParsed;\n    }\n    if (token) {\n      kc.token = token;\n      kc.tokenParsed = decodeToken(token);\n      kc.sessionId = kc.tokenParsed.sid;\n      kc.authenticated = true;\n      kc.subject = kc.tokenParsed.sub;\n      kc.realmAccess = kc.tokenParsed.realm_access;\n      kc.resourceAccess = kc.tokenParsed.resource_access;\n      if (timeLocal) {\n        kc.timeSkew = Math.floor(timeLocal / 1000) - kc.tokenParsed.iat;\n      }\n      if (kc.timeSkew != null) {\n        logInfo('[KEYCLOAK] Estimated time difference between browser and server is ' + kc.timeSkew + ' seconds');\n        if (kc.onTokenExpired) {\n          var expiresIn = (kc.tokenParsed['exp'] - new Date().getTime() / 1000 + kc.timeSkew) * 1000;\n          logInfo('[KEYCLOAK] Token expires in ' + Math.round(expiresIn / 1000) + ' s');\n          if (expiresIn <= 0) {\n            kc.onTokenExpired();\n          } else {\n            kc.tokenTimeoutHandle = setTimeout(kc.onTokenExpired, expiresIn);\n          }\n        }\n      }\n    } else {\n      delete kc.token;\n      delete kc.tokenParsed;\n      delete kc.subject;\n      delete kc.realmAccess;\n      delete kc.resourceAccess;\n      kc.authenticated = false;\n    }\n  }\n  function createUUID() {\n    if (typeof crypto === \"undefined\" || typeof crypto.randomUUID === \"undefined\") {\n      throw new Error(\"Web Crypto API is not available.\");\n    }\n    return crypto.randomUUID();\n  }\n  function parseCallback(url) {\n    var oauth = parseCallbackUrl(url);\n    if (!oauth) {\n      return;\n    }\n    var oauthState = callbackStorage.get(oauth.state);\n    if (oauthState) {\n      oauth.valid = true;\n      oauth.redirectUri = oauthState.redirectUri;\n      oauth.storedNonce = oauthState.nonce;\n      oauth.prompt = oauthState.prompt;\n      oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;\n      oauth.loginOptions = oauthState.loginOptions;\n    }\n    return oauth;\n  }\n  function parseCallbackUrl(url) {\n    var supportedParams;\n    switch (kc.flow) {\n      case 'standard':\n        supportedParams = ['code', 'state', 'session_state', 'kc_action_status', 'kc_action', 'iss'];\n        break;\n      case 'implicit':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n        break;\n      case 'hybrid':\n        supportedParams = ['access_token', 'token_type', 'id_token', 'code', 'state', 'session_state', 'expires_in', 'kc_action_status', 'kc_action', 'iss'];\n        break;\n    }\n    supportedParams.push('error');\n    supportedParams.push('error_description');\n    supportedParams.push('error_uri');\n    var queryIndex = url.indexOf('?');\n    var fragmentIndex = url.indexOf('#');\n    var newUrl;\n    var parsed;\n    if (kc.responseMode === 'query' && queryIndex !== -1) {\n      newUrl = url.substring(0, queryIndex);\n      parsed = parseCallbackParams(url.substring(queryIndex + 1, fragmentIndex !== -1 ? fragmentIndex : url.length), supportedParams);\n      if (parsed.paramsString !== '') {\n        newUrl += '?' + parsed.paramsString;\n      }\n      if (fragmentIndex !== -1) {\n        newUrl += url.substring(fragmentIndex);\n      }\n    } else if (kc.responseMode === 'fragment' && fragmentIndex !== -1) {\n      newUrl = url.substring(0, fragmentIndex);\n      parsed = parseCallbackParams(url.substring(fragmentIndex + 1), supportedParams);\n      if (parsed.paramsString !== '') {\n        newUrl += '#' + parsed.paramsString;\n      }\n    }\n    if (parsed && parsed.oauthParams) {\n      if (kc.flow === 'standard' || kc.flow === 'hybrid') {\n        if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.newUrl = newUrl;\n          return parsed.oauthParams;\n        }\n      } else if (kc.flow === 'implicit') {\n        if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {\n          parsed.oauthParams.newUrl = newUrl;\n          return parsed.oauthParams;\n        }\n      }\n    }\n  }\n  function parseCallbackParams(paramsString, supportedParams) {\n    var p = paramsString.split('&');\n    var result = {\n      paramsString: '',\n      oauthParams: {}\n    };\n    for (var i = 0; i < p.length; i++) {\n      var split = p[i].indexOf(\"=\");\n      var key = p[i].slice(0, split);\n      if (supportedParams.indexOf(key) !== -1) {\n        result.oauthParams[key] = p[i].slice(split + 1);\n      } else {\n        if (result.paramsString !== '') {\n          result.paramsString += '&';\n        }\n        result.paramsString += p[i];\n      }\n    }\n    return result;\n  }\n  function createPromise() {\n    // Need to create a native Promise which also preserves the\n    // interface of the custom promise type previously used by the API\n    var p = {\n      setSuccess: function (result) {\n        p.resolve(result);\n      },\n      setError: function (result) {\n        p.reject(result);\n      }\n    };\n    p.promise = new Promise(function (resolve, reject) {\n      p.resolve = resolve;\n      p.reject = reject;\n    });\n    return p;\n  }\n\n  // Function to extend existing native Promise with timeout\n  function applyTimeoutToPromise(promise, timeout, errorMessage) {\n    var timeoutHandle = null;\n    var timeoutPromise = new Promise(function (resolve, reject) {\n      timeoutHandle = setTimeout(function () {\n        reject({\n          \"error\": errorMessage || \"Promise is not settled within timeout of \" + timeout + \"ms\"\n        });\n      }, timeout);\n    });\n    return Promise.race([promise, timeoutPromise]).finally(function () {\n      clearTimeout(timeoutHandle);\n    });\n  }\n  function setupCheckLoginIframe() {\n    var promise = createPromise();\n    if (!loginIframe.enable) {\n      promise.setSuccess();\n      return promise.promise;\n    }\n    if (loginIframe.iframe) {\n      promise.setSuccess();\n      return promise.promise;\n    }\n    var iframe = document.createElement('iframe');\n    loginIframe.iframe = iframe;\n    iframe.onload = function () {\n      var authUrl = kc.endpoints.authorize();\n      if (authUrl.charAt(0) === '/') {\n        loginIframe.iframeOrigin = getOrigin();\n      } else {\n        loginIframe.iframeOrigin = authUrl.substring(0, authUrl.indexOf('/', 8));\n      }\n      promise.setSuccess();\n    };\n    var src = kc.endpoints.checkSessionIframe();\n    iframe.setAttribute('src', src);\n    iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n    iframe.setAttribute('title', 'keycloak-session-iframe');\n    iframe.style.display = 'none';\n    document.body.appendChild(iframe);\n    var messageCallback = function (event) {\n      if (event.origin !== loginIframe.iframeOrigin || loginIframe.iframe.contentWindow !== event.source) {\n        return;\n      }\n      if (!(event.data == 'unchanged' || event.data == 'changed' || event.data == 'error')) {\n        return;\n      }\n      if (event.data != 'unchanged') {\n        kc.clearToken();\n      }\n      var callbacks = loginIframe.callbackList.splice(0, loginIframe.callbackList.length);\n      for (var i = callbacks.length - 1; i >= 0; --i) {\n        var promise = callbacks[i];\n        if (event.data == 'error') {\n          promise.setError();\n        } else {\n          promise.setSuccess(event.data == 'unchanged');\n        }\n      }\n    };\n    window.addEventListener('message', messageCallback, false);\n    return promise.promise;\n  }\n  function scheduleCheckIframe() {\n    if (loginIframe.enable) {\n      if (kc.token) {\n        setTimeout(function () {\n          checkLoginIframe().then(function (unchanged) {\n            if (unchanged) {\n              scheduleCheckIframe();\n            }\n          });\n        }, loginIframe.interval * 1000);\n      }\n    }\n  }\n  function checkLoginIframe() {\n    var promise = createPromise();\n    if (loginIframe.iframe && loginIframe.iframeOrigin) {\n      var msg = kc.clientId + ' ' + (kc.sessionId ? kc.sessionId : '');\n      loginIframe.callbackList.push(promise);\n      var origin = loginIframe.iframeOrigin;\n      if (loginIframe.callbackList.length == 1) {\n        loginIframe.iframe.contentWindow.postMessage(msg, origin);\n      }\n    } else {\n      promise.setSuccess();\n    }\n    return promise.promise;\n  }\n  function check3pCookiesSupported() {\n    var promise = createPromise();\n    if ((loginIframe.enable || kc.silentCheckSsoRedirectUri) && typeof kc.endpoints.thirdPartyCookiesIframe === 'function') {\n      var iframe = document.createElement('iframe');\n      iframe.setAttribute('src', kc.endpoints.thirdPartyCookiesIframe());\n      iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');\n      iframe.setAttribute('title', 'keycloak-3p-check-iframe');\n      iframe.style.display = 'none';\n      document.body.appendChild(iframe);\n      var messageCallback = function (event) {\n        if (iframe.contentWindow !== event.source) {\n          return;\n        }\n        if (event.data !== \"supported\" && event.data !== \"unsupported\") {\n          return;\n        } else if (event.data === \"unsupported\") {\n          logWarn(\"[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\\n\\n\" + \" - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\\n\" + \" - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\\n\\n\" + \"For more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers\");\n          loginIframe.enable = false;\n          if (kc.silentCheckSsoFallback) {\n            kc.silentCheckSsoRedirectUri = false;\n          }\n        }\n        document.body.removeChild(iframe);\n        window.removeEventListener(\"message\", messageCallback);\n        promise.setSuccess();\n      };\n      window.addEventListener('message', messageCallback, false);\n    } else {\n      promise.setSuccess();\n    }\n    return applyTimeoutToPromise(promise.promise, kc.messageReceiveTimeout, \"Timeout when waiting for 3rd party check iframe message.\");\n  }\n  function loadAdapter(type) {\n    if (!type || type == 'default') {\n      return {\n        login: async function (options) {\n          window.location.assign(await kc.createLoginUrl(options));\n          return createPromise().promise;\n        },\n        logout: async function (options) {\n          const logoutMethod = options?.logoutMethod ?? kc.logoutMethod;\n          if (logoutMethod === \"GET\") {\n            window.location.replace(kc.createLogoutUrl(options));\n            return;\n          }\n\n          // Create form to send POST request.\n          const form = document.createElement(\"form\");\n          form.setAttribute(\"method\", \"POST\");\n          form.setAttribute(\"action\", kc.createLogoutUrl(options));\n          form.style.display = \"none\";\n\n          // Add data to form as hidden input fields.\n          const data = {\n            id_token_hint: kc.idToken,\n            client_id: kc.clientId,\n            post_logout_redirect_uri: adapter.redirectUri(options, false)\n          };\n          for (const [name, value] of Object.entries(data)) {\n            const input = document.createElement(\"input\");\n            input.setAttribute(\"type\", \"hidden\");\n            input.setAttribute(\"name\", name);\n            input.setAttribute(\"value\", value);\n            form.appendChild(input);\n          }\n\n          // Append form to page and submit it to perform logout and redirect.\n          document.body.appendChild(form);\n          form.submit();\n        },\n        register: async function (options) {\n          window.location.assign(await kc.createRegisterUrl(options));\n          return createPromise().promise;\n        },\n        accountManagement: function () {\n          var accountUrl = kc.createAccountUrl();\n          if (typeof accountUrl !== 'undefined') {\n            window.location.href = accountUrl;\n          } else {\n            throw \"Not supported by the OIDC server\";\n          }\n          return createPromise().promise;\n        },\n        redirectUri: function (options, encodeHash) {\n          if (arguments.length == 1) {\n            encodeHash = true;\n          }\n          if (options && options.redirectUri) {\n            return options.redirectUri;\n          } else if (kc.redirectUri) {\n            return kc.redirectUri;\n          } else {\n            return location.href;\n          }\n        }\n      };\n    }\n    if (type == 'cordova') {\n      loginIframe.enable = false;\n      var cordovaOpenWindowWrapper = function (loginUrl, target, options) {\n        if (window.cordova && window.cordova.InAppBrowser) {\n          // Use inappbrowser for IOS and Android if available\n          return window.cordova.InAppBrowser.open(loginUrl, target, options);\n        } else {\n          return window.open(loginUrl, target, options);\n        }\n      };\n      var shallowCloneCordovaOptions = function (userOptions) {\n        if (userOptions && userOptions.cordovaOptions) {\n          return Object.keys(userOptions.cordovaOptions).reduce(function (options, optionName) {\n            options[optionName] = userOptions.cordovaOptions[optionName];\n            return options;\n          }, {});\n        } else {\n          return {};\n        }\n      };\n      var formatCordovaOptions = function (cordovaOptions) {\n        return Object.keys(cordovaOptions).reduce(function (options, optionName) {\n          options.push(optionName + \"=\" + cordovaOptions[optionName]);\n          return options;\n        }, []).join(\",\");\n      };\n      var createCordovaOptions = function (userOptions) {\n        var cordovaOptions = shallowCloneCordovaOptions(userOptions);\n        cordovaOptions.location = 'no';\n        if (userOptions && userOptions.prompt == 'none') {\n          cordovaOptions.hidden = 'yes';\n        }\n        return formatCordovaOptions(cordovaOptions);\n      };\n      var getCordovaRedirectUri = function () {\n        return kc.redirectUri || 'http://localhost';\n      };\n      return {\n        login: async function (options) {\n          var promise = createPromise();\n          var cordovaOptions = createCordovaOptions(options);\n          var loginUrl = await kc.createLoginUrl(options);\n          var ref = cordovaOpenWindowWrapper(loginUrl, '_blank', cordovaOptions);\n          var completed = false;\n          var closed = false;\n          var closeBrowser = function () {\n            closed = true;\n            ref.close();\n          };\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n              var callback = parseCallback(event.url);\n              processCallback(callback, promise);\n              closeBrowser();\n              completed = true;\n            }\n          });\n          ref.addEventListener('loaderror', function (event) {\n            if (!completed) {\n              if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                var callback = parseCallback(event.url);\n                processCallback(callback, promise);\n                closeBrowser();\n                completed = true;\n              } else {\n                promise.setError();\n                closeBrowser();\n              }\n            }\n          });\n          ref.addEventListener('exit', function (event) {\n            if (!closed) {\n              promise.setError({\n                reason: \"closed_by_user\"\n              });\n            }\n          });\n          return promise.promise;\n        },\n        logout: function (options) {\n          var promise = createPromise();\n          var logoutUrl = kc.createLogoutUrl(options);\n          var ref = cordovaOpenWindowWrapper(logoutUrl, '_blank', 'location=no,hidden=yes,clearcache=yes');\n          var error;\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n              ref.close();\n            }\n          });\n          ref.addEventListener('loaderror', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n              ref.close();\n            } else {\n              error = true;\n              ref.close();\n            }\n          });\n          ref.addEventListener('exit', function (event) {\n            if (error) {\n              promise.setError();\n            } else {\n              kc.clearToken();\n              promise.setSuccess();\n            }\n          });\n          return promise.promise;\n        },\n        register: async function (options) {\n          var promise = createPromise();\n          var registerUrl = await kc.createRegisterUrl();\n          var cordovaOptions = createCordovaOptions(options);\n          var ref = cordovaOpenWindowWrapper(registerUrl, '_blank', cordovaOptions);\n          ref.addEventListener('loadstart', function (event) {\n            if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n              ref.close();\n              var oauth = parseCallback(event.url);\n              processCallback(oauth, promise);\n            }\n          });\n          return promise.promise;\n        },\n        accountManagement: function () {\n          var accountUrl = kc.createAccountUrl();\n          if (typeof accountUrl !== 'undefined') {\n            var ref = cordovaOpenWindowWrapper(accountUrl, '_blank', 'location=no');\n            ref.addEventListener('loadstart', function (event) {\n              if (event.url.indexOf(getCordovaRedirectUri()) == 0) {\n                ref.close();\n              }\n            });\n          } else {\n            throw \"Not supported by the OIDC server\";\n          }\n        },\n        redirectUri: function (options) {\n          return getCordovaRedirectUri();\n        }\n      };\n    }\n    if (type == 'cordova-native') {\n      loginIframe.enable = false;\n      return {\n        login: async function (options) {\n          var promise = createPromise();\n          var loginUrl = await kc.createLoginUrl(options);\n          universalLinks.subscribe('keycloak', function (event) {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            var oauth = parseCallback(event.url);\n            processCallback(oauth, promise);\n          });\n          window.cordova.plugins.browsertab.openUrl(loginUrl);\n          return promise.promise;\n        },\n        logout: function (options) {\n          var promise = createPromise();\n          var logoutUrl = kc.createLogoutUrl(options);\n          universalLinks.subscribe('keycloak', function (event) {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            kc.clearToken();\n            promise.setSuccess();\n          });\n          window.cordova.plugins.browsertab.openUrl(logoutUrl);\n          return promise.promise;\n        },\n        register: async function (options) {\n          var promise = createPromise();\n          var registerUrl = await kc.createRegisterUrl(options);\n          universalLinks.subscribe('keycloak', function (event) {\n            universalLinks.unsubscribe('keycloak');\n            window.cordova.plugins.browsertab.close();\n            var oauth = parseCallback(event.url);\n            processCallback(oauth, promise);\n          });\n          window.cordova.plugins.browsertab.openUrl(registerUrl);\n          return promise.promise;\n        },\n        accountManagement: function () {\n          var accountUrl = kc.createAccountUrl();\n          if (typeof accountUrl !== 'undefined') {\n            window.cordova.plugins.browsertab.openUrl(accountUrl);\n          } else {\n            throw \"Not supported by the OIDC server\";\n          }\n        },\n        redirectUri: function (options) {\n          if (options && options.redirectUri) {\n            return options.redirectUri;\n          } else if (kc.redirectUri) {\n            return kc.redirectUri;\n          } else {\n            return \"http://localhost\";\n          }\n        }\n      };\n    }\n    throw 'invalid adapter type: ' + type;\n  }\n  const STORAGE_KEY_PREFIX = 'kc-callback-';\n  var LocalStorage = function () {\n    if (!(this instanceof LocalStorage)) {\n      return new LocalStorage();\n    }\n    localStorage.setItem('kc-test', 'test');\n    localStorage.removeItem('kc-test');\n    var cs = this;\n\n    /**\n     * Clears all values from local storage that are no longer valid.\n     */\n    function clearInvalidValues() {\n      const currentTime = Date.now();\n      for (const [key, value] of getStoredEntries()) {\n        // Attempt to parse the expiry time from the value.\n        const expiry = parseExpiry(value);\n\n        // Discard the value if it is malformed or expired.\n        if (expiry === null || expiry < currentTime) {\n          localStorage.removeItem(key);\n        }\n      }\n    }\n\n    /**\n     * Clears all known values from local storage.\n     */\n    function clearAllValues() {\n      for (const [key] of getStoredEntries()) {\n        localStorage.removeItem(key);\n      }\n    }\n\n    /**\n     * Gets all entries stored in local storage that are known to be managed by this class.\n     * @returns {Array<[string, unknown]>} An array of key-value pairs.\n     */\n    function getStoredEntries() {\n      return Object.entries(localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX));\n    }\n\n    /**\n     * Parses the expiry time from a value stored in local storage.\n     * @param {unknown} value\n     * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.\n     */\n    function parseExpiry(value) {\n      let parsedValue;\n\n      // Attempt to parse the value as JSON.\n      try {\n        parsedValue = JSON.parse(value);\n      } catch (error) {\n        return null;\n      }\n\n      // Attempt to extract the 'expires' property.\n      if (isObject(parsedValue) && 'expires' in parsedValue && typeof parsedValue.expires === 'number') {\n        return parsedValue.expires;\n      }\n      return null;\n    }\n    cs.get = function (state) {\n      if (!state) {\n        return;\n      }\n      var key = STORAGE_KEY_PREFIX + state;\n      var value = localStorage.getItem(key);\n      if (value) {\n        localStorage.removeItem(key);\n        value = JSON.parse(value);\n      }\n      clearInvalidValues();\n      return value;\n    };\n    cs.add = function (state) {\n      clearInvalidValues();\n      const key = STORAGE_KEY_PREFIX + state.state;\n      const value = JSON.stringify({\n        ...state,\n        // Set the expiry time to 1 hour from now.\n        expires: Date.now() + 60 * 60 * 1000\n      });\n      try {\n        localStorage.setItem(key, value);\n      } catch (error) {\n        // If the storage is full, clear all known values and try again.\n        clearAllValues();\n        localStorage.setItem(key, value);\n      }\n    };\n  };\n  var CookieStorage = function () {\n    if (!(this instanceof CookieStorage)) {\n      return new CookieStorage();\n    }\n    var cs = this;\n    cs.get = function (state) {\n      if (!state) {\n        return;\n      }\n      var value = getCookie(STORAGE_KEY_PREFIX + state);\n      setCookie(STORAGE_KEY_PREFIX + state, '', cookieExpiration(-100));\n      if (value) {\n        return JSON.parse(value);\n      }\n    };\n    cs.add = function (state) {\n      setCookie(STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), cookieExpiration(60));\n    };\n    cs.removeItem = function (key) {\n      setCookie(key, '', cookieExpiration(-100));\n    };\n    var cookieExpiration = function (minutes) {\n      var exp = new Date();\n      exp.setTime(exp.getTime() + minutes * 60 * 1000);\n      return exp;\n    };\n    var getCookie = function (key) {\n      var name = key + '=';\n      var ca = document.cookie.split(';');\n      for (var i = 0; i < ca.length; i++) {\n        var c = ca[i];\n        while (c.charAt(0) == ' ') {\n          c = c.substring(1);\n        }\n        if (c.indexOf(name) == 0) {\n          return c.substring(name.length, c.length);\n        }\n      }\n      return '';\n    };\n    var setCookie = function (key, value, expirationDate) {\n      var cookie = key + '=' + value + '; ' + 'expires=' + expirationDate.toUTCString() + '; ';\n      document.cookie = cookie;\n    };\n  };\n  function createCallbackStorage() {\n    try {\n      return new LocalStorage();\n    } catch (err) {}\n    return new CookieStorage();\n  }\n  function createLogger(fn) {\n    return function () {\n      if (kc.enableLogging) {\n        fn.apply(console, Array.prototype.slice.call(arguments));\n      }\n    };\n  }\n}\nexport default Keycloak;\n\n/**\n * @param {ArrayBuffer} bytes\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n */\nfunction bytesToBase64(bytes) {\n  const binString = String.fromCodePoint(...bytes);\n  return btoa(binString);\n}\n\n/**\n * @param {string} message\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#basic_example\n */\nasync function sha256Digest(message) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  if (typeof crypto === \"undefined\" || typeof crypto.subtle === \"undefined\") {\n    throw new Error(\"Web Crypto API is not available.\");\n  }\n  return await crypto.subtle.digest(\"SHA-256\", data);\n}\n\n/**\n * @param {string} token\n */\nfunction decodeToken(token) {\n  const [header, payload] = token.split(\".\");\n  if (typeof payload !== \"string\") {\n    throw new Error(\"Unable to decode token, payload not found.\");\n  }\n  let decoded;\n  try {\n    decoded = base64UrlDecode(payload);\n  } catch (error) {\n    throw new Error(\"Unable to decode token, payload is not a valid Base64URL value.\", {\n      cause: error\n    });\n  }\n  try {\n    return JSON.parse(decoded);\n  } catch (error) {\n    throw new Error(\"Unable to decode token, payload is not a valid JSON value.\", {\n      cause: error\n    });\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction base64UrlDecode(input) {\n  let output = input.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\");\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += \"==\";\n      break;\n    case 3:\n      output += \"=\";\n      break;\n    default:\n      throw new Error(\"Input is not of the correct length.\");\n  }\n  try {\n    return b64DecodeUnicode(output);\n  } catch (error) {\n    return atob(output);\n  }\n}\n\n/**\n * @param {string} input\n */\nfunction b64DecodeUnicode(input) {\n  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {\n    let code = p.charCodeAt(0).toString(16).toUpperCase();\n    if (code.length < 2) {\n      code = \"0\" + code;\n    }\n    return \"%\" + code;\n  }));\n}\n\n/**\n * Check if the input is an object that can be operated on.\n * @param {unknown} input\n */\nfunction isObject(input) {\n  return typeof input === 'object' && input !== null;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}